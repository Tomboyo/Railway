= Withp

A hobby-project to frame logic patterns.

== Sink

Sink fills a similar role to the `with` expression, but better accomodates data collisions. Its goal is to let an author compose a function pipeline out of (a) guard clauses that can short-circuit the pipeline and (b) regular functions that advance an intermediate state. By emphasizing function composition, the result resembles a table of contents. The maintainer can see at a glance the branching points in the algorithm, directing them towards helper functions they need to read, and away from those they don't.

Consider the following:

[source, elixir]
----
with {:ok, v1} <- f1(),
     {:ok, v2} <- f2(v1)
do
  # happy-path
else
  # pattern-match on errors
end
----

Suppose both `f1` and `f2` can return `:error`, but that if `f1` fails, we need to return a different value than if `f2` fails. We can achieve this by wrapping either of `f1` or `f2` in a local helper function to replace `:error` with a unique value. This is tedious, however, because many functions collide in this way. We would need to write helper functions pretty frequently.

The other solution is to abandon `with` completely and intersperse guarding `if` clauses into the algorithm that can return early. This clutters the algorithm with imperative control flow, but we can abstract that control flow away. This is essentially how Sink works: It is a framework that inserts guards between transform functions in a computation. If a guard trips, further processing is preempted and a result immediately computed:

[source, elixir]
----
from(request)
  |> guard(&missing_username_param?/1, &error_400/1)
  |> guard(&missing_preference_param?/1, &error_400/1)
  |> transform(&fetch_user/1) #=> { User?, Preference }
  |> guard(&no_such_user?/1, &error_404/1)
  |> transform(&update_user_preferences/1) #=> :ok | :error
  |> guard(&is_error?/1, &error_500/1)
  |> guard(&is_ok?/1, &ok_200/1)
  |> finish()
  #=> Response(400) | Response(404) | Response(200) | Response(500)
----

Here we attempt to update a user's preferences when we receive an Http request. If their username or preference is missing from the request, we evaluate to a 400 response. If we cannot find the given user in our database, we evaluate to a 404 response. Otherwise, we update their preferences. Here we used two terminal guard clauses; in terminal position, they must be exhaustive (one must match). This lets the pipeline self-verify.
