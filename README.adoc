= Withp: With, but Pipelined

Withp, to rhyme with lisp, is a library to smoothly integrate error-returning
functions into pipelines.

This fills a similar role to the `with` expression:

[source, elixir]
----
with {:ok, v1} <- f1(),
     {:ok, v2} <- f2(v1)
do
  # happy-path
else
  # pattern-match on errors
end
----

However, `with` expressions have no way to to handle error cases differently
when the same error _value_, such as `:error`, is produced by two or more
different _functions_, such as `f1` and `f2` above. The `with ... else`
expression cannot determine through pattern-matching alone which `:error` is
which even though the difference matters.

There is also little way to indicate that a function should _always_ match its
pattern in a `with` expression (and therefore that if it does not, the program
has a bug).

Withp attempts to provide an alternative mechanism to `with` through the
`Withp.Try` module.

== Withp.Try

Try is a functor used to compose many functions together, any of which may
evaluate to an error (like `{:error, _}` or `:error`), and to compute a result
whether that happens or not.

Suppose we have a pipeline `:some_input |> foo |> bar |> baz` and we want to
return "it worked!" if all goes well. Both `bar` and `baz` can return `:error`,
and we want to return either "bar broke!" or "baz broke!" depending on which
fails. A Try pipeline to achieve this could look like:

[source, elixir]
----
of!(fn -> foo(:some_input) end)     <1>
    |> map_ok(:missing_bar, &bar/1) <2>
    |> map_ok(:missing_baz, &baz/1)
    |> reduce(                      <3>
      fn value -> "it worked!" end,
      fn error ->
        case error do
          e = {:missing_bar, _value, _context} -> "bar broke!"
          e = {:missing_baz, _value, _context} -> "baz broke!"
        end
      end)
----
<1> `of!/1` starts a Try pipeline. The "bang" notation indicates that `foo/1`
     should never return an error. `of!/1` will _raise_ an error if this
     assumption is ever violated.
<3> `map_ok/3` transforms the value of a Try. The first error encountered
     by a pipeline, if any, causes any remaining map operations to be ignored:
     The pipeline "short-circuits". Errors are tagged with values like
     `:missing_bar` to contextualize their source for later handling.
<4> `reduce/3` evaluates a Try pipeline to an arbitrary value. In this case,
    if all went well, the Try evaluates to "it worked!". Otherwise, the
    tagged errors are matched and resolve to one of "bar broke!" or
    "baz broke!". In addition to a tag, each error tuple contains the value of
    the Try at point of failure as well as the context of the error (e.g,
    `{:error, context}`) if present.

See the `Withp.Try` module documentation for more information.
